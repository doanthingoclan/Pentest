# BÁO CÁO TASK 3

============================

# Chương 6 : CÁC LỆNH ĐIỀU KHIỂN RẼ NHÁNH.

**1.Lệnh nhảy .**

				Chương trình PGM6_1.ASM
		1: TITLE	PGM6_1: hiện thị các ký tự IBM.
		2: .MODEL	 SMALL
		3: .STACK	100H
		4: .CODE
		5: MAIN	PROC
		6:	MOV		AH,2		;hàm hiển thị ký tự
		7: 	MOV		 CX,256	;số ký tự được hiển thị
		8:	MOV		 DL,0 		;DL chứa mã ASCII ký tự NULL
		9: PRINT_LOOP:
		10:	INT 		21h	;hiển thị một ký tự
		11:	INC 		DL ; tăng mã ACSII
		12:	DEC 		CX ;giảm bộ đếm
		13:	JNZ		PRINT_LOOP	;lặp lại nếu CX khác 0
		14:	;trở về DOS
		15:	MOV 	AH,4Ch
		16:	INT 		21H
		17: MAIN	ENDP
		18:	END MAIN
		
**Để hiện thị các ký tự : dùng vòng lặp ( từ 9 đến 13 ). Trước khi vào vòng lặp:**

>- AH được khởi tạo giá trị 2 (hàm hiển thị một ký tự) 
>- DL được đặt bằng 0 là mã ASCII ký tự đầu tiên. 
>- CX là bộ đếm vòng lặp, được đặt bằng 256 trc khi vào vòng lặp và giảm 1 sau mỗi ký tự được hiển thị.

**Lệnh JNZ điều khiển vòng lặp. Nếu :**

>- Lệnh kế trước (**DEC	CX**) khác 0 , lệnh sẽ chuyển điều khiển đến lệnh có nhãn **PRINT_LOOP** .
>- Khi **DX =0** chương trình tiếp tục thực hiện các lệnh trở về **DOS** .

+ Các mã ASCII của các ký tự điều khiển như lùi một ký tự, về đầu dòng, ….. các chức năng điều khiển sẽ được thực hiện thay vì hiển thị 
chúng .

+ *Lưu ý*: **PRINT_LOOP** là nhãn dòng lệnh đầu sử dụng trong một chương trình. Nhãn kết thúc bằng dấu hai chấm và được đặt riêng một dòng. Các nhãn tham trỏ tới lệnh ngay sau chúng .

**2. Các lệnh nhảy có điều kiện .**

- JNZ là một ví dụ của lệnh nhảy có điều kiện . **Cú pháp :**

		JNZ		nhãn_đích
		
		
- Lệnh nhãn_đích có thể ở trước hoặc sau lệnh nhảy. Nếu đk không thỏa mãn, lệnh ngay sau lệnh nhảy sẽ được thi hành.
**Điều kiện :** Kết quả của lệnh trc nó khác 0 .

- Phạm vi của lệnh nhảy có điều kiện : **nhãn_đích** phải đứng trc lệnh nhảy =< 126 byte or đứng sau =<127 byte .

**CPU thực hiện một lệnh nhảy như thế nào ?**

+ Để thực hiện một lệnh nhảy, CPU nhìn vào thanh ghi cờ:

>- Nếu đk của lệnh nhảy thỏa mãn, CPU điều chỉnh IP trỏ đến nhãn đích và như thế lệnh ở sau nhãn sẽ được thi hành tiếp theo .
>- Ngược lại, IP không bị sửa đổi , lệnh trên dòng tiếp theo sẽ được thi hành .

+ Trong chương trình trên, CPU thi hành lệnh **JNZ**, **PRINT_LOOP** phụ thuộc vào **ZF**:

>- ZF =0 : chuyển tới nhãn **PRINT_LOOP** .
>- ZF =1 : tiếp tục thực hiện lệnh `MOV	  AH,4Ch`.

+ Lệnh nhảy có điều khiển gồm 3 loại :

>- Các lệnh nhảy có dấu được dùng khi kết quả trả về là các số có dấu .
>- Các lệnh nhảy không dấu dùng với các số không dấu .
>- Các lệnh nhảy điều khiện đơn: đk phụ thuộc vào một cờ riêng biệt .

- **Lưu ý** : Các lệnh nhảy tự nó không ảnh hưởng đến cờ .

					Bảng . Các lệnh nhảy có điều kiện .
	Các lệnh nhảy có dấu.
	Ký hiệu			Chức năng				Điều kiện nhảy
	JG/JNLE			nhảy nếu lớn hơn			ZF=0 và SF = OF
				nhảy nếu không nhỏ hơn hay bằng
	JGE/JNL			không nhỏ hơn hay bằng			SF=OF
				không nhỏ hơn
	JL/JNGE			nhỏ hơn					SF<>OF
				Không lớn hơn hay bằng
	JLE/JNG			nhỏ hơn hay bằng			ZF=1 hay SF=OF
				Không lớn hơn
====================

	Các lệnh nhảy không dấu
	JA/JNBE			lớn hơn					CF=0 và ZF=0
				Không nhỏ hơn hay bằng
	JAE/JNB			lớn hơn hay bằng			CF=0
				Không nhỏ hơn
	JB/JNAE			nhỏ hơn					CF=1
				Không lớn hơn hay bằng
	JBE/JNA			nhỏ hơn hay bằng			CF=1 hay ZF =1
				Không lớn hơn .

===================
				
	Các lệnh nhảy điều kiện đơn
	Ký hiệu			Chức năng				Điều kiện nhảy

	JE/JZ			bằng					ZF=1
				Bằng 0
	JNE/JNZ			không bằng				ZF=0
				Khác 0
	JC			có nhớ					CF=1
	JNC			không nhớ				CF=0
	JO			nếu tràn				OF=1
	JNO			không tràn				OF=0
	JS			dấu âm					SF=1
	JNS			dấu dương				SF=0
	JP/JPE			cờ chẵn					PF=1
	JNP/JPO			cờ lẻ					PF=0
	

**Lệnh CMP**

- Các lệnh nhảy thường được cung cấp bởi lệnh **CMP ( compare )** .

			CMP	    đích , nguồn
			
- **Chức năng** : So sánh toán tử đích với toán tử nguồn bằng cách lấy toán tử đích – toán tử nguồn . Kết quả không lưu lại nhưng các cờ bị ảnh hưởng. Các toán hạng của **CMP** không cùng là các ô nhớ , toán hạng đích không là hằng số.

- **Chú ý** : **CMP** giống như **SUB** trừ việc toán hạng đích không bị thay đổi .

**Ví dụ : Giả thiết chương trình chứa hai dòng lệnh sau :**
			CPM		AX,BX
			JG		BELOW

> AX = 7FFFh , BX = 0001
> Kết quả so sánh là 7FFFh – 0001h = 7FFEh .
> Điều kiện nhảy lệnh JG được thỏa mản vì ZF =SF=OF =0 nên điều khiển được chuyển đến **BELOW** .

**Dịch các lệnh có điều kiện :**

- Không cần chú ý nhiều về các cờ, có thể dùng tên của lệnh nhảy để qđ việc chuyển điều khiển đến nhãn đích . **Các lệnh sau :**

			CMP 		AX,BX
			JG		BELOW
			
- Nếu **AX > BX** thì **JG (jump if greater than)** sẽ chuyển đến **BELOW** .

**VD:**

			DEC		AX
			JL		THERE
			
>Nếu AX < 0, điều khiển sẽ được chuyển đến THERE .
>So sáng các lệnh nhảy có dấu và không dấu: Mỗi lệnh nhảy có dấu đều tương ứng với một lệnh nhảy không dấu .

**VD: Với các số không dấu . Nếu như AX = 7FFFh và BX = 8000h, ta thực hiện :**

			CMP		AX,BX
			JA		BELOW
			
> Nếu 7FFFh > 8000h trong dạng có dấu , chương trình vẫn không nhảy đến nhãn BELOW
> Nguyên nhân: 7FFFh < 8000h ở dạng không dấu và ở đây dùng lệnh nhảy không dấu JA .
> Làm việc với ký tự .

**VD: Giả sử AX và BX chứa các số có dấu . Lệnh để đưa số lớn nhất vào CX .**

			MOV		CX,AX		; đưa AX và CX
			CMP		BX,CX		; BX lớn hơn ?
			JLE		NEXT		; không, tiếp tục
			MOV		CX,BX		; đúng, đưa BX vào CX
			
# 3.Lệnh JMP (jump)

- **Cú pháp :** 

			JMP		đích
			
- **JMP** có thể được dùng để khắc phục  khoảng giới hạn của lệnh nhảy có điều kiện. 
**VD : giả sử chúng ta muốn thực hiện vòng lặp :**

			TOP:
			;than vòng lặp
				DEC	CX	;giảm bộ đếm
				JNZ	TOP	; lặp nếu CX >0 
			
+ Thân vòng lặp lại chứa quà nhiều lệnh đến mức nhãn TOP nằm ngoài khoảng giới hạn của lệnh **JNZ** ( > 126 b trước  **JNZ	    TOP**).

***Sửa lại :***

			TOP:
			; thân vòng lặp
				DEC	CX	;giảm bộ đếm
				JNZ	BOTTOM	; lặp nếu CX > 0
				JMP	EXIT
			BOTTOM: JMP	TOP
				EXIT :	MOV	AX,BX
				
# 4.Cấu trúc rẽ nhánh .

- Để chọn các đường dẫn khác nhau và phụ thuộc vào điều kiện:

			IF_THEN
			
- Cấu trúc này có thể được khai báo dưới dạng phần tử như sau :

			IF điều _kiện
				THEN
					Nhánh_đúng
				END_if
- Điều_kiện là một biểu thức có thể đúng or sai. Nếu đúng, nhánh_đúng sẽ thực hiện . Ngược lại cấu trúc không thực hiện lệnh nào, ct tiếp tục với các lệnh theo sau .

**VD . Thay số trong AX bằng giá trị tuyệt đối của nó .**

+ Một thuật toán với mã lệnh giả :

			IF	AX>0
			THEN
				Thay AX = - AX
			END_IF
+ Mã hóa :

			;if AX>0
				CMP	AX,0		; AX<0 ?
				JNL	END_IF	; không , thoát ra .
			; then	
				NEG	AX		; đúng, đổi dấu
			END IF:
			
			
> Đk AX<0 được kt bởi lệnh `CMP	  AX,0` .Nếu AX không nhỏ hơn 0, ta không phải làm gì cả , **JNL** dùng để nhảy `NEG	AX`,  
nếu AX<0 thỏa mãn , tiếp tục lệnh  `NEG 	AX`.

			IF_THEN_ELSE
			IF	điều_kiện
			THEN
				Nhánh_đúng
			ELSE
				Nhánh_sai
			END_IF
			
> Nếu điều_kiện đúng , nhóm lệnh nhánh_đúng sẽ được thi hành. Ngược lại , nhóm lệnh nhánh _sai sẽ thi hành .

**VD: AL và BL chứa ký tự ASCII mở rộng. Hiển thi ký tự đứng trc trong bảng mã .**

			IF	AL<=BL
				THEN
					Hiển thị ký tự trong AL
			ELSE
					Hiện thị kí tự trong BL
			END_IF
			
> Mã hóa:
		
			MOV	AH,2		;chuẩn bị hiển thị
		; if AL<=BL
			CMP	AL,BL		; AL<=BL  ?
			JNBE	ELSE_		; không, hiển thị ký tự trong BL
		; then				; AL< = BL
			MOV	DL,AL		; chuyển ký tự vào DL để hiện thị
			JMP	DISPLAY		; tới DISPLAY
		ELSE_:
			MOV	DL,BL		; chuyển ký tự vào DL để hiển thị
		DISPLAY:
			INT	21h		; hiển thị nó .
		; END_IF
		
***Chú ý :*** Ta dùng nhãn **ELSE_** vì **ELSE** là từ dành riêng .

- AL<=BL được kt bởi CMP	AL,BL . Sai : nhảy qua nhánh_đúng tới ELSE_ . Sử dụng lệnh nhảy không dấu JNBE bởi đg thực hiện so sánh các ký tự mở rộng .
-	AL<=BL thỏa mãn, nhánh_đúng được thực hiện . Chỉ thị JMP	DISPLAY là cần thiết để nhảy qua nhánh_sai. Khác với ngôn ngữ bậc cao: nhánh _ sai được tự động nhảy qua nếu nhánh_đúng được thực hiện.
CASE
-	Là cấu trúc đa nhánh, nó kiểm tra thanh ghi, các biến hay các biểu thức với giá trị riêng rẽ .
-	TQ: CASE phát biểu
			giá_trị_1: dòng_lệnh_1
			giá_trị_2: dòng_lệnh_2
.
			.
			giá_trị_n: dòng_lệnh_n
END_CASE
VD: Nếu AX chứa 1 số âm, nhập -1 vào BX, nếu AX chứa 0, cho BX bằng 0 , nếu AX dương đổi BX thành 1.
CASE	AX
	<0: gán BX bằng 1
	=0: gán BX bằng 0
	>0: gán BX bằng 1
END_CASE
Mã hóa:
;case AX
	CMP	AX,0			;kiểm tra AX
	JL		NEGATIVE		;AX<0
	JG		POSITIVE		; AX>0
NEGATIVE:
	MOV	BX,-1			; nhập -1 vào BX
	JMP		END_CASE		;rồi thoát
ZERO:
	MOV	BX,0			; nhập 0 vào BX
	JMP		END_CASE		; rồi thoát
POSITIVE:
	MOV	BX,1			; nhập 1 vào BX
END_CASE:
Các nhánh với điều kiện kép.
điều_kiện_1		AND		điều_kiện_2
hay
điều_kiện_1		OR	điều_kiện_2
Các điều kiện AND
Điều kiện AND chỉ đúng khi cả hai điều kiện: điều_kiện_1 và điều_kiện_2 cùng đúng. Ngược lại nếu một trong chúng sai, đk AND cũng sai.
VD: Đọc một ký tự. Nếu là chữ hoa thì hiển thị nó.
Đọc một ký tự ( vào DL )
IF( ‘A’<= ký_tự ) và ( ký_tự <=’Z’ )
THEN
	hiện thị ký tự
END_IF
Mã hóa:
;đọc một ký tự
	MOV	AH,1		; chuẩn bị đọc
	INT		21h		; ký tự vào AL
; if ( ‘A’ <= ký_tự ) và ( ký_tự <= ‘Z’ )
	CMP	AL,’A’	; ký_tự >=’A’ ?
	JNGE	END_IF	; không, thoát ra
	CMP	AL,’Z’	;ký tự>=’Z’ ?
	JNLE	END_IF	; không, thoát ra
; then hiển thị ký tự
	MOV	DL,AL	; lấy ký tự
	MOV	AH,2		; chuẩn bị hiển thị
	INT		21h		; hiển thị ký tự
END_IF:
Các điều kiện OR.
Điều_kiện_1 OR điều_kiện_2 là đúng khi điều_kiện_1 hoặc điều_kiện_2 đúng. Nó chỉ sai khi cả hai điều kiện thành phần cùng sai.
VD: Đọc 1 ký tự. Nếu là ‘y’ hay ’Y’ thì hiển thị nó. Nếu ngược lại, kết thúc chương trình .
Đọc một ký tự (vào AL).
IF ( ký_tự = ‘y’) hoặc ( ký_tự = ‘Y’)
THEN
	hiển thị ký tự
ELSE
	kết thúc chương trình.
END_IF
Mã hóa:
;đọc một ký tự
	MOV	AH,1		;chuẩn bị đọc
	INT		21h		; ký tự trong AL
; if ( ký_tự = ‘y’ ) hoặc ( ký_tự = ‘Y’ )
	CMP	AL,’y’	;ký_tự = ‘y’
	JE		THEN		; đúng, chuyển đến hiển thị ký tự
	CMP	AL, ‘Y’	; ký_tự = ‘Y’
	JE		THEN		; đúng, chuyển đến hiển thị ký tự
	JMP		ELSE_	; sai, kết thúc
THEN:
	MOV	AH,2		; chuẩn bị hiển thị
	MOV	DL,AL	; lấy ký tự
	INT		21h		; hiển thị nó
	JMP		END_IF	; và thoát ra
ELSE_ :
	MOV	AH,4Ch	;
	INT		21h		; trở về DOS
END_IF :
5.	Các cấu trúc lặp .
Một vòng lặp là một chuỗi các lệnh được lặp lại. Số lần lặp có thể đã xác định trước hoặc phụ thuộc vào các điều kiện .
Vòng lặp FOR .
Đây là một cấu trúc lặp mà số lần lặp lại các dòng lệnh đã biết trước . Dạng mã lệnh giả :
	FOR		số_lần_lặp	DO
		các dòng lệnh
	END_FOR
Ta có thể sử dụng lệnh LOOP để thực hiện vòng lặp FOR. Lệnh này có dạng : 
	LOOP	nhãn_đích
Bộ đếm vòng lặp: CX = số _lần_lặp . Mỗi lần thực hiện LOOP, CX tự động giảm 1 và nếu CX khác 0 thì chuyển tới nhãn đích. Nếu CX = 0, lệnh tiếp sau LOOP sẽ được thi hành. Nhãn đích phải ở trc lệnh lặp không quá 126 byte .
	Vòng lặp FOR có thể được thực hiện nhờ lệnh LOOP như sau :
	;khởi tạo CX bằng số _ lần_lặp
TOP:
	; thân vòng lặp
	LOOP TOP
VD: Viết một vòng lặp điều khiển bằng biến đếm hiển thị một dòng 80 dấu sao .
FOR	80 times	DO
	hiển thị	‘*’
END_FOR
Mã lệnh:
	MOV	CX,80		;số các dấu sao được hiển thị
	MOV	AH,2		; hàm hiển thị ký tự
	MOV	DL,’*’	; hiển thị ký tự
TOP:
	INT		21h		; hiển thị dấu sao
	LOOP	TOP		; lặp lại 80 lần
Do nếu CX =0 khi vào vòng lặp , LOOP giảm CX = 0FFFFh vào sẽ thực hiện 0FFFFh = 65535 lần nữa . Đề khắc phục điều này, lệnh JCXZ ( jump if CX if zero ) được đặt trc vòng lặp . Cú pháp :
	JCXZ	nhãn_đích
Nếu CX=0, điều khiển sẽ được chuyển đến nhãn_đích . Như vậy vòng lặp sẽ bỏ qua nếu CX =0 :
	JCXZ	SKIP
TOP:
	; thân vòng lặp
	LOOP	TOP
SKIP :
Vòng lặp WHILE .
Vòng lặp này phụ thuộc vào một điều kiện . Dạng mã lệnh giả :
	WHILE	điều_kiện	DO
		các dòng lệnh
	END_WHILE
Điều_kiện được kiểm tra ở đầu vòng lặp. Nếu đúng dòng lệnh sẽ thi hành, ngược lại nếu sai, chương trình tiếp tục thực hiện lệnh ở sau vòng lặp. 
Trong TH ngay khi khởi đầu điều_kiện đã không thỏa mãn, thân vòng lặp sẽ không thực hiện lần nào . Và tiếp tục khi đk còn đúng.
VD: Viết các lệnh để đếm số ký tự trong một dòng .
Khởi tạo bộ đếm bằng 0 ,
đọc một ký tự
WHILE	ký tự <> ký tự về đầu hàng	DO
	đếm = đếm + 1
	đọc một ký tự
END_WHILE
Các lệnh :
	MOV	DX,0		;DX đếm số ký tự
	MOV	AH,1		; chuẩn bị đọc	
	INT		21h		; ký tự trong AL
WHILE_:
	CMP	AL,0Dh		; CR ?
	JE		END_WHILE	; đúng, thoát ra
	INC		DX			; không phải CR, tăng bộ đếm
	INT		21h			; đọc một ký tự
	JMP		WHILE		; lặp lại
END_WHILE
Lưu ý: Bất cứ biến nào liên quan đến đk vòng lặp đều phải được khởi tạo . Vì vậy phải đọc một ký tự trc khi vào vòng lặp rồi lại phải đọc ký tự khác ở cuối nó . Ta dùng nhãn WHILE_ vì WHILE là từ dành riêng .
Vòng lặp REPEAT
Mã lệnh :
REPEAT
	các dòng lệnh
UNTIL	điều_kiện
Ở vòng lặp trên , các dòng lênh được thi hành sau đó mới kiểm tra điều kiện. Nếu đúng , vòng lặp kết thúc, nếu sai điều khiển rẽ nhánh đến đầu vòng lặp .
VD: Viết các dòng lệnh đọc vào ký tự, kết thúc khi gặp một ký tự trắng.
REPEAT
	Đọc một ký tự
UNTIL	ký tự trắng
Các lệnh là :
	MOV	AH,1		;chuẩn bị đọc
REPEAT:
	INT		21h		;ký tự trong AL
;until
	CMP	AL, ‘ ’	; ký tự trắng ?
	JNE		REPEAT	; không, đọc tiếp
So sánh WHILE và REPEAT
Sử dụng 2 vòng lặp trên là tùy ý thích của mỗi người. 
Ưu điểm của WHILE : vòng lặp được bỏ qua khi đk kết thúc khởi tạo với giá trị logic sai ( REPEAT phải thực hiện ít nhất 1 lần )
Ưu điểm của WHILE : lệnh ngắn hơn bởi nó chỉ có một lệnh nhảy có đk ở cuối ( WHILE có những hai : lệnh nhảy ở đầu và lệnh JMP ở cuối ) .

Chương trình PGM6_2.ASM
TITLE	PGM6_2: Chữ hoa đầu và cuối .
.MODEL	SMALL
.STACK	100H
.DATA
PROMPT	DB ‘ Bạn hãy vào một dòng văn bản’, 0Dh,0Ah,’$’
NOCAP	MSG	DB	0DH,0AH,’Không có chữ hoa ! $’
CAP_MSG			DB	‘Chứ hoa đầu tiên = ’
FIRST			DB	‘[ ’
			DB	‘ Chữ hoa sau cùng = ’
LAST			DB	‘@ $ ’
.CODE
MAIN	PROC
;khởi tạo DS
	MOV	AX,@DATA
	MOV	DS,AX
;hiển thị thông báo ban đầu
	MOV	AH,9			;chức năng hiển thị chuỗi
	LEA		DX,PROMPT	;lấy thông báo ban đầu
	INT		21h			; hiển thị nó
;đọc và xử ký một dòng văn bản
	MOV	AH,1			;hàm đọc ký tự
	INT		21h			; ký tự trong AL
WHILE_ :
;while 	không phải ký tự xuống dòng   		do 
	CMP		AL,0Dh		;CR ?
	JE		END_WHILE	; đúng, thoát ra
; if   ký tự là chữ hoa
	CMP	AL, ‘A’		; ký tự > = ‘A’ ?
	JNGE	END_IF		; không phải chữ hoa .
	CMP	AL, ‘Z’		; ký tự <= ‘Z’ ?
	JNLE	END_IF		; không phải chữ hoa
;then
;if ký tự đúng trước chữ hoa đầu
	CMP	AL,FIRST		; ký tự < FIRST ?
	JNL		CHECK_LAST	; không, kiểm tra tiếp
;then chữ hoa đầu = ký tự
	MOV	FIRST, AL		; FIRST = ký tự
;end_if
CHECK_LAST :
;if ký tự đứng sau chữ hoa cuối
	CMP	AL,LAST		;ký tự > LAST
	JNG		END_IF		; không, cho qua
;then	chữ hoa cuối 	ký tự
	MOV	LAST,AL		;LAST = ký tự
;end_if
END_IF:
;đọc một ký tự
	INT			21h			; ký tự trong AL
	JMP		WHILE_		;lặp lại
END_WHILE :
;hiển thị kết quả
	MOV	AH,9			; hàm hiển thị chuỗi
; if không có chữ hoa
	CMP	FIRST,’[ ’		;FIRST = ‘[ ’ ?
	JNE		CAPS			; không, hiển thị kết quả
; then
	LEA		DX, NOCAP_MSG
	JMP		DISPLAY
CAPS:
	LEA		DX,CAP_MSG
DISPLAY:
	INT		21h			; hiển thị thông báo
;end_if
;trở về DOS
	MOV	AH,4CH
	INT		21h
MAIN	ENDP
	END	MAIN




















































































	
























































































































